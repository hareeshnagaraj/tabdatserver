{"_id":"lockfile","_rev":"42-ddcc525cd54ebc35f2607a2ef3105a66","name":"lockfile","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","dist-tags":{"latest":"0.4.2"},"versions":{"0.1.0":{"name":"lockfile","description":"A simple utility for creating/checking lockfiles","keywords":["tool","fs"],"author":{"name":"Trevor Burnham"},"email":"trevorburnham@gmail.com","homepage":"http://github.com/TrevorBurnham/lockfile","repository":{"type":"git","url":"http://github.com/TrevorBurnham/lockfile.git"},"licenses":[{"type":"MIT"}],"version":"0.1.0","engines":{"node":">= 0.2.0"},"directories":{"lib":"./lib"},"main":"./lib/lockfile","_id":"lockfile@0.1.0","_engineSupported":true,"_npmVersion":"0.2.16","_nodeVersion":"v0.2.5","modules":{"lockfile.js":"lib/lockfile.js"},"files":[""],"_defaultsLoaded":true,"dist":{"shasum":"f2c4129ae6cc8d033b5ca9ae7d30775a727ab588","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.1.0.tgz"}},"0.1.1":{"name":"lockfile","description":"A simple utility for creating/checking lockfiles","keywords":["tool","fs"],"author":{"name":"Trevor Burnham"},"email":"trevorburnham@gmail.com","homepage":"http://github.com/TrevorBurnham/lockfile","repository":{"type":"git","url":"git://github.com/TrevorBurnham/lockfile.git"},"licenses":[{"type":"MIT"}],"version":"0.1.1","engines":{"node":">= 0.2.0"},"directories":{"lib":"./lib"},"main":"./lib/lockfile","_npmUser":{"name":"TrevorBurnham","email":"trevorburnham@gmail.com"},"_id":"lockfile@0.1.1","dependencies":{},"devDependencies":{},"_engineSupported":true,"_npmVersion":"1.0.105","_nodeVersion":"v0.6.2","_defaultsLoaded":true,"dist":{"shasum":"188122a8ecc5a58aff3cc54cbaf431e66a0d179f","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.1.1.tgz"},"maintainers":[{"name":"TrevorBurnham","email":"trevorburnham@gmail.com"}]},"0.2.0":{"name":"lockfile","version":"0.2.0","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er, fd) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the fd is opened in\n  // wx mode.  If you want to write something to it, go ahead.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path.  Returns the FD.\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","_id":"lockfile@0.2.0","dist":{"shasum":"b3a18167839d5b4b3319e693ca44035807a98d5f","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.2.0.tgz"},"maintainers":[{"name":"TrevorBurnham","email":"trevorburnham@gmail.com"},{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.2.1":{"name":"lockfile","version":"0.2.1","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er, fd) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the fd is opened in\n  // wx mode.  If you want to write something to it, go ahead.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path.  Returns the FD.\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","_id":"lockfile@0.2.1","dist":{"shasum":"d581b3e3651a2499b65a21df8d1403e83b573fca","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.2.1.tgz"},"maintainers":[{"name":"TrevorBurnham","email":"trevorburnham@gmail.com"},{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.2.2":{"name":"lockfile","version":"0.2.2","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er, fd) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the fd is opened in\n  // wx mode.  If you want to write something to it, go ahead.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path.  Returns the FD.\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","readmeFilename":"README.md","_id":"lockfile@0.2.2","dist":{"shasum":"1231b8f27618dddd9c72ae666e0471030d51e23e","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.2.2.tgz"},"_from":".","_npmVersion":"1.2.3","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.3.0":{"name":"lockfile","version":"0.3.0","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er, fd) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the fd is opened in\n  // wx mode.  If you want to write something to it, go ahead.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path.  Returns the FD.\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","readmeFilename":"README.md","_id":"lockfile@0.3.0","dist":{"shasum":"60618302a2dd3e0970cfffbf419da94a011234ea","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.3.0.tgz"},"_from":".","_npmVersion":"1.2.4","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.3.1":{"name":"lockfile","version":"0.3.1","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5","touch":"0"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er, fd) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the fd is opened in\n  // wx mode.  If you want to write something to it, go ahead.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path.  Returns the FD.\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","readmeFilename":"README.md","_id":"lockfile@0.3.1","dist":{"shasum":"8b1772b4a9f16d964db05951ce6697825ed248e8","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.3.1.tgz"},"_from":".","_npmVersion":"1.2.18","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.3.2":{"name":"lockfile","version":"0.3.2","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5","touch":"0"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er, fd) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the fd is opened in\n  // wx mode.  If you want to write something to it, go ahead.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path.  Returns the FD.\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/lockfile/issues"},"_id":"lockfile@0.3.2","dist":{"shasum":"542261743479f9f907be30441f5d6b95e8b95722","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.3.2.tgz"},"_from":".","_npmVersion":"1.2.19","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.3.3":{"name":"lockfile","version":"0.3.3","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5","touch":"0"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er, fd) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the fd is opened in\n  // wx mode.  If you want to write something to it, go ahead.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path.  Returns the FD.\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/lockfile/issues"},"_id":"lockfile@0.3.3","dist":{"shasum":"fd5fda603546bf7206fae47f9c7f6f060505aab4","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.3.3.tgz"},"_from":".","_npmVersion":"1.2.27","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.3.4":{"name":"lockfile","version":"0.3.4","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5","touch":"0"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er, fd) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the fd is opened in\n  // wx mode.  If you want to write something to it, go ahead.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path.  Returns the FD.\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/lockfile/issues"},"_id":"lockfile@0.3.4","dist":{"shasum":"932b63546e4915f81b71924b36187740358eda03","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.3.4.tgz"},"_from":".","_npmVersion":"1.2.28","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.4.0":{"name":"lockfile","version":"0.4.0","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5","touch":"0"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the file was created,\n  // and won't be deleted until we unlock it.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/lockfile/issues"},"_id":"lockfile@0.4.0","dist":{"shasum":"0f815a7ee7c3d603ddec6fbfa8a212b5645d54c5","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.4.0.tgz"},"_from":".","_npmVersion":"1.3.2","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.4.1":{"name":"lockfile","version":"0.4.1","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5","touch":"0"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the file was created,\n  // and won't be deleted until we unlock it.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/lockfile/issues"},"_id":"lockfile@0.4.1","dist":{"shasum":"307b3aeb2983999f1ee3c26161d2f5878b574c8a","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.4.1.tgz"},"_from":".","_npmVersion":"1.3.8","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]},"0.4.2":{"name":"lockfile","version":"0.4.2","main":"lockfile.js","directories":{"test":"test"},"dependencies":{},"devDependencies":{"tap":"~0.2.5","touch":"0"},"scripts":{"test":"tap test/*.js"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"keywords":["lockfile","lock","file","fs","O_EXCL"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"license":"BSD","description":"A very polite lock file utility, which endeavors to not litter, and to wait patiently for others.","readme":"# lockfile\n\nA very polite lock file utility, which endeavors to not litter, and to\nwait patiently for others.\n\n## Usage\n\n```javascript\nvar lockFile = require('lockfile')\n\n// opts is optional, and defaults to {}\nlockFile.lock('some-file.lock', opts, function (er) {\n  // if the er happens, then it failed to acquire a lock.\n  // if there was not an error, then the file was created,\n  // and won't be deleted until we unlock it.\n\n  // do my stuff, free of interruptions\n  // then, some time later, do:\n  lockFile.unlock('some-file.lock', function (er) {\n    // er means that an error happened, and is probably bad.\n  })\n})\n```\n\n## Methods\n\nSync methods return the value/throw the error, others don't.  Standard\nnode fs stuff.\n\nAll known locks are removed when the process exits.  Of course, it's\npossible for certain types of failures to cause this to fail, but a best\neffort is made to not be a litterbug.\n\n### lockFile.lock(path, [opts], cb)\n\nAcquire a file lock on the specified path\n\n### lockFile.lockSync(path, [opts])\n\nAcquire a file lock on the specified path\n\n### lockFile.unlock(path, cb)\n\nClose and unlink the lockfile.\n\n### lockFile.unlockSync(path)\n\nClose and unlink the lockfile.\n\n### lockFile.check(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nReturns boolean.\n\n### lockFile.checkSync(path, [opts], cb)\n\nCheck if the lockfile is locked and not stale.\n\nCallback is called with `cb(error, isLocked)`.\n\n## Options\n\n### opts.wait\n\nA number of milliseconds to wait for locks to expire before giving up.\nOnly used by lockFile.lock.  Relies on fs.watch.  If the lock is not\ncleared by the time the wait expires, then it returns with the original\nerror.\n\n### opts.stale\n\nA number of milliseconds before locks are considered to have expired.\n\n### opts.retries\n\nUsed by lock and lockSync.  Retry `n` number of times before giving up.\n\n### opts.retryWait\n\nUsed by lock.  Wait `n` milliseconds before retrying.\n","readmeFilename":"README.md","bugs":{"url":"https://github.com/isaacs/lockfile/issues"},"_id":"lockfile@0.4.2","dist":{"shasum":"ab91f5d3745bc005ae4fa34d078910d1f2b9612d","tarball":"http://registry.npmjs.org/lockfile/-/lockfile-0.4.2.tgz"},"_from":".","_npmVersion":"1.3.8","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}]}},"maintainers":[{"name":"trevorburnham","email":"trevorburnham@gmail.com"},{"name":"isaacs","email":"i@izs.me"}],"time":{"modified":"2013-08-23T20:26:52.739Z","created":"2011-01-31T02:18:35.133Z","0.1.0":"2011-01-31T02:18:35.974Z","0.1.1":"2012-01-19T17:27:12.988Z","0.2.0":"2012-06-27T16:24:49.880Z","0.2.1":"2012-06-27T21:30:27.566Z","0.2.2":"2013-01-27T21:47:52.507Z","0.3.0":"2013-02-06T00:48:21.546Z","0.3.1":"2013-04-27T17:23:03.317Z","0.3.2":"2013-05-11T00:23:11.885Z","0.3.3":"2013-06-07T21:49:48.655Z","0.3.4":"2013-06-07T23:56:52.220Z","0.4.0":"2013-07-11T06:50:35.010Z","0.4.1":"2013-08-21T04:48:43.635Z","0.4.2":"2013-08-23T20:26:52.739Z"},"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git://github.com/isaacs/lockfile"},"users":{"werle":true,"finalclass":true},"_attachments":{},"_etag":"\"BE6HUPSNPXI5QOIOUTQKTZG1O\""}